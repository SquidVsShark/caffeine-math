

[VERTEX]
#version 150 core

/* Standard vertex input */
in vec3 in_vs_position;
in vec2 in_vs_texture_coord;
in vec3 in_vs_normal;

uniform mat4 world;
uniform mat4 wvp;

out vec2 in_ps_texcoord;
out vec3 in_ps_normal;
out vec3 in_ps_world_position;


void
main()
{
   in_ps_texcoord       = in_vs_texture_coord;
   in_ps_normal         = (world * vec4(in_vs_normal, 0.0)).xyz;
   gl_Position          = wvp * vec4(in_vs_position, 1.0);
   in_ps_world_position = (world * vec4(in_vs_position, 1.0)).xyz;
}
[/VERTEX]


[PIXEL]
#version 150 core

#define MAX_DIR_LIGHTS 1
#define MAX_POINT_LIGHTS 5


//#include "shadow_funcs.shd"  // below has dependencies which need to be removed.

/*
  Light structures
*/
struct Directional_light
{
  vec3  color;
  vec3  direction;
  float ambient;
  float diffuse;
};


/*
  Generic lighting algorithm
*/
vec4
calculate_light(vec3 eye_pos,
                vec3 world_pos,
                vec3 normal,
                vec3 light_color,
                vec3 light_direction,
                float ambient,
                float diffuse,
                float spec_intensity,
                float spec_power,
                float shadow)
{
  normal = normalize(normal);

  vec4 ambient_color  = vec4(light_color * ambient, 1.0f);
  vec4 diffuse_color  = vec4(0, 0, 0, 0);
  vec4 specular_color = vec4(0, 0, 0, 0);

  float diffuse_factor = max(dot(normal, -normalize(light_direction)), 0);

  //if (diffuse_factor > 0)
  {
    diffuse_color = mix(vec4(light_color, 1.0f) * diffuse * diffuse_factor,
                        vec4(0,0,0,0),
                        float(diffuse_factor <= 0));

    vec3 vert_to_eye   = normalize(eye_pos - world_pos);
    vec3 reflect_light = normalize(reflect(light_direction, normal));
    float spec_factor  = dot(vert_to_eye, reflect_light);

    //if(spec_factor > 0)
    {
      spec_factor    = pow(spec_factor, spec_power);
      specular_color = mix(vec4(light_color * spec_intensity * spec_factor, 1.0f),
                           vec4(0,0,0,0),
                           float(spec_factor <= 0));
    }
  }

  return vec4((ambient_color + shadow) * (diffuse_color + specular_color));
  //return vec4(shadow, shadow, shadow, 1);
}


in vec2 in_ps_texcoord;
in vec3 in_ps_normal;
in vec3 in_ps_world_position;

uniform vec3              eye_position;
uniform float             specular_power = 1;
uniform float             specular_intensity = 1;
uniform sampler2D         diffuse_map;
uniform Directional_light dir_light;

out vec4 out_ps_color;


void
main()
{
  vec4 combined_lights = vec4(0,0,0,0);

  combined_lights += calculate_light(eye_position,
                                     in_ps_world_position,
                                     in_ps_normal,
                                     dir_light.color,
                                     dir_light.direction,
                                     dir_light.ambient,
                                     dir_light.diffuse,
                                     specular_intensity,
                                     specular_power,
                                     0);

  out_ps_color = texture(diffuse_map, in_ps_texcoord) * (combined_lights);
}
[/PIXEL]